// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: serve/service_fish/domain/probability/proto/probability.proto

package probability_proto

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	proto2 "serve/fish_comm/common/proto"
	proto3 "serve/service_fish/domain/gamerecovery/proto"
	proto1 "serve/service_fish/models/proto"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OPTION_MODE int32

const (
	OPTION_MODE_eGetSelectRedEnvelopeOption OPTION_MODE = 0
	OPTION_MODE_eGetSelectSlot777Option     OPTION_MODE = 1
)

var OPTION_MODE_name = map[int32]string{
	0: "eGetSelectRedEnvelopeOption",
	1: "eGetSelectSlot777Option",
}

var OPTION_MODE_value = map[string]int32{
	"eGetSelectRedEnvelopeOption": 0,
	"eGetSelectSlot777Option":     1,
}

func (x OPTION_MODE) String() string {
	return proto.EnumName(OPTION_MODE_name, int32(x))
}

func (OPTION_MODE) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{0}
}

type HitFish struct {
	Uuid     string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	SymbolId int32  `protobuf:"varint,2,opt,name=symbol_id,json=symbolId,proto3" json:"symbol_id,omitempty"`
	RtpId    string `protobuf:"bytes,3,opt,name=rtpId,proto3" json:"rtpId,omitempty"`
}

func (m *HitFish) Reset()         { *m = HitFish{} }
func (m *HitFish) String() string { return proto.CompactTextString(m) }
func (*HitFish) ProtoMessage()    {}
func (*HitFish) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{0}
}
func (m *HitFish) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HitFish) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HitFish.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HitFish) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HitFish.Merge(m, src)
}
func (m *HitFish) XXX_Size() int {
	return m.Size()
}
func (m *HitFish) XXX_DiscardUnknown() {
	xxx_messageInfo_HitFish.DiscardUnknown(m)
}

var xxx_messageInfo_HitFish proto.InternalMessageInfo

func (m *HitFish) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *HitFish) GetSymbolId() int32 {
	if m != nil {
		return m.SymbolId
	}
	return 0
}

func (m *HitFish) GetRtpId() string {
	if m != nil {
		return m.RtpId
	}
	return ""
}

type HitBullet struct {
	BonusUuid      string        `protobuf:"bytes,1,opt,name=bonus_uuid,json=bonusUuid,proto3" json:"bonus_uuid,omitempty"`
	Uuid           string        `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	TypeId         int32         `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	Target         *proto1.Point `protobuf:"bytes,4,opt,name=target,proto3" json:"target,omitempty"`
	ShootMode      int32         `protobuf:"varint,5,opt,name=shoot_mode,json=shootMode,proto3" json:"shoot_mode,omitempty"`
	AccumulatedPay uint64        `protobuf:"varint,6,opt,name=accumulated_pay,json=accumulatedPay,proto3" json:"accumulated_pay,omitempty"`
}

func (m *HitBullet) Reset()         { *m = HitBullet{} }
func (m *HitBullet) String() string { return proto.CompactTextString(m) }
func (*HitBullet) ProtoMessage()    {}
func (*HitBullet) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{1}
}
func (m *HitBullet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HitBullet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HitBullet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HitBullet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HitBullet.Merge(m, src)
}
func (m *HitBullet) XXX_Size() int {
	return m.Size()
}
func (m *HitBullet) XXX_DiscardUnknown() {
	xxx_messageInfo_HitBullet.DiscardUnknown(m)
}

var xxx_messageInfo_HitBullet proto.InternalMessageInfo

func (m *HitBullet) GetBonusUuid() string {
	if m != nil {
		return m.BonusUuid
	}
	return ""
}

func (m *HitBullet) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *HitBullet) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *HitBullet) GetTarget() *proto1.Point {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *HitBullet) GetShootMode() int32 {
	if m != nil {
		return m.ShootMode
	}
	return 0
}

func (m *HitBullet) GetAccumulatedPay() uint64 {
	if m != nil {
		return m.AccumulatedPay
	}
	return 0
}

type HitResult struct {
	Pay              uint64 `protobuf:"varint,1,opt,name=pay,proto3" json:"pay,omitempty"`
	Multiplier       int32  `protobuf:"varint,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	PlayerCent       uint64 `protobuf:"varint,3,opt,name=player_cent,json=playerCent,proto3" json:"player_cent,omitempty"`
	BulletPay        uint64 `protobuf:"varint,4,opt,name=bullet_pay,json=bulletPay,proto3" json:"bullet_pay,omitempty"`
	BulletCollection uint64 `protobuf:"varint,5,opt,name=bullet_collection,json=bulletCollection,proto3" json:"bullet_collection,omitempty"`
}

func (m *HitResult) Reset()         { *m = HitResult{} }
func (m *HitResult) String() string { return proto.CompactTextString(m) }
func (*HitResult) ProtoMessage()    {}
func (*HitResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{2}
}
func (m *HitResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HitResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HitResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HitResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HitResult.Merge(m, src)
}
func (m *HitResult) XXX_Size() int {
	return m.Size()
}
func (m *HitResult) XXX_DiscardUnknown() {
	xxx_messageInfo_HitResult.DiscardUnknown(m)
}

var xxx_messageInfo_HitResult proto.InternalMessageInfo

func (m *HitResult) GetPay() uint64 {
	if m != nil {
		return m.Pay
	}
	return 0
}

func (m *HitResult) GetMultiplier() int32 {
	if m != nil {
		return m.Multiplier
	}
	return 0
}

func (m *HitResult) GetPlayerCent() uint64 {
	if m != nil {
		return m.PlayerCent
	}
	return 0
}

func (m *HitResult) GetBulletPay() uint64 {
	if m != nil {
		return m.BulletPay
	}
	return 0
}

func (m *HitResult) GetBulletCollection() uint64 {
	if m != nil {
		return m.BulletCollection
	}
	return 0
}

type TriggerBonus struct {
	Uuid           string     `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	TypeId         int32      `protobuf:"varint,2,opt,name=type_id,json=typeId,proto3" json:"type_id,omitempty"`
	Times          int32      `protobuf:"varint,3,opt,name=times,proto3" json:"times,omitempty"`
	BonusExtraInfo *ExtraInfo `protobuf:"bytes,4,opt,name=bonusExtraInfo,proto3" json:"bonusExtraInfo,omitempty"`
}

func (m *TriggerBonus) Reset()         { *m = TriggerBonus{} }
func (m *TriggerBonus) String() string { return proto.CompactTextString(m) }
func (*TriggerBonus) ProtoMessage()    {}
func (*TriggerBonus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{3}
}
func (m *TriggerBonus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerBonus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerBonus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerBonus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerBonus.Merge(m, src)
}
func (m *TriggerBonus) XXX_Size() int {
	return m.Size()
}
func (m *TriggerBonus) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerBonus.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerBonus proto.InternalMessageInfo

func (m *TriggerBonus) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *TriggerBonus) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *TriggerBonus) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *TriggerBonus) GetBonusExtraInfo() *ExtraInfo {
	if m != nil {
		return m.BonusExtraInfo
	}
	return nil
}

type ExtraInfo struct {
	BonusPays     []int32 `protobuf:"varint,1,rep,packed,name=bonusPays,proto3" json:"bonusPays,omitempty"`
	BonusLocation []int32 `protobuf:"varint,2,rep,packed,name=bonusLocation,proto3" json:"bonusLocation,omitempty"`
}

func (m *ExtraInfo) Reset()         { *m = ExtraInfo{} }
func (m *ExtraInfo) String() string { return proto.CompactTextString(m) }
func (*ExtraInfo) ProtoMessage()    {}
func (*ExtraInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{4}
}
func (m *ExtraInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtraInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtraInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtraInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtraInfo.Merge(m, src)
}
func (m *ExtraInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExtraInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtraInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExtraInfo proto.InternalMessageInfo

func (m *ExtraInfo) GetBonusPays() []int32 {
	if m != nil {
		return m.BonusPays
	}
	return nil
}

func (m *ExtraInfo) GetBonusLocation() []int32 {
	if m != nil {
		return m.BonusLocation
	}
	return nil
}

type ResultCall struct {
	Msgid         proto2.EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	Token         string        `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	RoomUuid      string        `protobuf:"bytes,3,opt,name=room_uuid,json=roomUuid,proto3" json:"room_uuid,omitempty"`
	SeatId        int32         `protobuf:"varint,4,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	HitFish       *HitFish      `protobuf:"bytes,5,opt,name=hit_fish,json=hitFish,proto3" json:"hit_fish,omitempty"`
	HitBullet     *HitBullet    `protobuf:"bytes,6,opt,name=hit_bullet,json=hitBullet,proto3" json:"hit_bullet,omitempty"`
	MercenaryType int32         `protobuf:"varint,7,opt,name=mercenary_type,json=mercenaryType,proto3" json:"mercenary_type,omitempty"`
}

func (m *ResultCall) Reset()         { *m = ResultCall{} }
func (m *ResultCall) String() string { return proto.CompactTextString(m) }
func (*ResultCall) ProtoMessage()    {}
func (*ResultCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{5}
}
func (m *ResultCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultCall.Merge(m, src)
}
func (m *ResultCall) XXX_Size() int {
	return m.Size()
}
func (m *ResultCall) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultCall.DiscardUnknown(m)
}

var xxx_messageInfo_ResultCall proto.InternalMessageInfo

func (m *ResultCall) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *ResultCall) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ResultCall) GetRoomUuid() string {
	if m != nil {
		return m.RoomUuid
	}
	return ""
}

func (m *ResultCall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *ResultCall) GetHitFish() *HitFish {
	if m != nil {
		return m.HitFish
	}
	return nil
}

func (m *ResultCall) GetHitBullet() *HitBullet {
	if m != nil {
		return m.HitBullet
	}
	return nil
}

func (m *ResultCall) GetMercenaryType() int32 {
	if m != nil {
		return m.MercenaryType
	}
	return 0
}

type MultiResultCall struct {
	Msgid         proto2.EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	Token         string        `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	RoomUuid      string        `protobuf:"bytes,3,opt,name=room_uuid,json=roomUuid,proto3" json:"room_uuid,omitempty"`
	SeatId        int32         `protobuf:"varint,4,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	HitFishies    []*HitFish    `protobuf:"bytes,5,rep,name=hit_fishies,json=hitFishies,proto3" json:"hit_fishies,omitempty"`
	HitBullet     *HitBullet    `protobuf:"bytes,6,opt,name=hit_bullet,json=hitBullet,proto3" json:"hit_bullet,omitempty"`
	MercenaryType int32         `protobuf:"varint,7,opt,name=mercenary_type,json=mercenaryType,proto3" json:"mercenary_type,omitempty"`
}

func (m *MultiResultCall) Reset()         { *m = MultiResultCall{} }
func (m *MultiResultCall) String() string { return proto.CompactTextString(m) }
func (*MultiResultCall) ProtoMessage()    {}
func (*MultiResultCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{6}
}
func (m *MultiResultCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiResultCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiResultCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiResultCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiResultCall.Merge(m, src)
}
func (m *MultiResultCall) XXX_Size() int {
	return m.Size()
}
func (m *MultiResultCall) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiResultCall.DiscardUnknown(m)
}

var xxx_messageInfo_MultiResultCall proto.InternalMessageInfo

func (m *MultiResultCall) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *MultiResultCall) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *MultiResultCall) GetRoomUuid() string {
	if m != nil {
		return m.RoomUuid
	}
	return ""
}

func (m *MultiResultCall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *MultiResultCall) GetHitFishies() []*HitFish {
	if m != nil {
		return m.HitFishies
	}
	return nil
}

func (m *MultiResultCall) GetHitBullet() *HitBullet {
	if m != nil {
		return m.HitBullet
	}
	return nil
}

func (m *MultiResultCall) GetMercenaryType() int32 {
	if m != nil {
		return m.MercenaryType
	}
	return 0
}

type ResultRecall struct {
	Msgid             proto2.EMSGID       `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	StatusCode        proto2.Status_Code  `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3,enum=common.proto.Status_Code" json:"status_code,omitempty"`
	RoomUuid          string              `protobuf:"bytes,3,opt,name=room_uuid,json=roomUuid,proto3" json:"room_uuid,omitempty"`
	SeatId            int32               `protobuf:"varint,4,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	BetRateLine       *proto1.BetRateLine `protobuf:"bytes,5,opt,name=bet_rate_line,json=betRateLine,proto3" json:"bet_rate_line,omitempty"`
	HitFish           *HitFish            `protobuf:"bytes,6,opt,name=hit_fish,json=hitFish,proto3" json:"hit_fish,omitempty"`
	HitBullet         *HitBullet          `protobuf:"bytes,7,opt,name=hit_bullet,json=hitBullet,proto3" json:"hit_bullet,omitempty"`
	HitResult         *HitResult          `protobuf:"bytes,8,opt,name=hit_result,json=hitResult,proto3" json:"hit_result,omitempty"`
	TriggerBonus      *TriggerBonus       `protobuf:"bytes,9,opt,name=trigger_bonus,json=triggerBonus,proto3" json:"trigger_bonus,omitempty"`
	ExtraTriggerBonus []*TriggerBonus     `protobuf:"bytes,10,rep,name=extra_trigger_bonus,json=extraTriggerBonus,proto3" json:"extra_trigger_bonus,omitempty"`
	MercenaryInfo     *proto3.Mercenary   `protobuf:"bytes,11,opt,name=mercenary_info,json=mercenaryInfo,proto3" json:"mercenary_info,omitempty"`
	MercenaryType     int32               `protobuf:"varint,12,opt,name=mercenary_type,json=mercenaryType,proto3" json:"mercenary_type,omitempty"`
}

func (m *ResultRecall) Reset()         { *m = ResultRecall{} }
func (m *ResultRecall) String() string { return proto.CompactTextString(m) }
func (*ResultRecall) ProtoMessage()    {}
func (*ResultRecall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{7}
}
func (m *ResultRecall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultRecall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultRecall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultRecall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultRecall.Merge(m, src)
}
func (m *ResultRecall) XXX_Size() int {
	return m.Size()
}
func (m *ResultRecall) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultRecall.DiscardUnknown(m)
}

var xxx_messageInfo_ResultRecall proto.InternalMessageInfo

func (m *ResultRecall) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *ResultRecall) GetStatusCode() proto2.Status_Code {
	if m != nil {
		return m.StatusCode
	}
	return proto2.Status_kSuccess
}

func (m *ResultRecall) GetRoomUuid() string {
	if m != nil {
		return m.RoomUuid
	}
	return ""
}

func (m *ResultRecall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *ResultRecall) GetBetRateLine() *proto1.BetRateLine {
	if m != nil {
		return m.BetRateLine
	}
	return nil
}

func (m *ResultRecall) GetHitFish() *HitFish {
	if m != nil {
		return m.HitFish
	}
	return nil
}

func (m *ResultRecall) GetHitBullet() *HitBullet {
	if m != nil {
		return m.HitBullet
	}
	return nil
}

func (m *ResultRecall) GetHitResult() *HitResult {
	if m != nil {
		return m.HitResult
	}
	return nil
}

func (m *ResultRecall) GetTriggerBonus() *TriggerBonus {
	if m != nil {
		return m.TriggerBonus
	}
	return nil
}

func (m *ResultRecall) GetExtraTriggerBonus() []*TriggerBonus {
	if m != nil {
		return m.ExtraTriggerBonus
	}
	return nil
}

func (m *ResultRecall) GetMercenaryInfo() *proto3.Mercenary {
	if m != nil {
		return m.MercenaryInfo
	}
	return nil
}

func (m *ResultRecall) GetMercenaryType() int32 {
	if m != nil {
		return m.MercenaryType
	}
	return 0
}

type MultiResultRecall struct {
	Msgid        proto2.EMSGID   `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	ResultRecall []*ResultRecall `protobuf:"bytes,2,rep,name=result_recall,json=resultRecall,proto3" json:"result_recall,omitempty"`
}

func (m *MultiResultRecall) Reset()         { *m = MultiResultRecall{} }
func (m *MultiResultRecall) String() string { return proto.CompactTextString(m) }
func (*MultiResultRecall) ProtoMessage()    {}
func (*MultiResultRecall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{8}
}
func (m *MultiResultRecall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiResultRecall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiResultRecall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiResultRecall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiResultRecall.Merge(m, src)
}
func (m *MultiResultRecall) XXX_Size() int {
	return m.Size()
}
func (m *MultiResultRecall) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiResultRecall.DiscardUnknown(m)
}

var xxx_messageInfo_MultiResultRecall proto.InternalMessageInfo

func (m *MultiResultRecall) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *MultiResultRecall) GetResultRecall() []*ResultRecall {
	if m != nil {
		return m.ResultRecall
	}
	return nil
}

type BroadcastResult struct {
	Msgid        proto2.EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	ResultRecall *ResultRecall `protobuf:"bytes,2,opt,name=result_recall,json=resultRecall,proto3" json:"result_recall,omitempty"`
}

func (m *BroadcastResult) Reset()         { *m = BroadcastResult{} }
func (m *BroadcastResult) String() string { return proto.CompactTextString(m) }
func (*BroadcastResult) ProtoMessage()    {}
func (*BroadcastResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{9}
}
func (m *BroadcastResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastResult.Merge(m, src)
}
func (m *BroadcastResult) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastResult.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastResult proto.InternalMessageInfo

func (m *BroadcastResult) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *BroadcastResult) GetResultRecall() *ResultRecall {
	if m != nil {
		return m.ResultRecall
	}
	return nil
}

type BroadcastMultiResult struct {
	Msgid             proto2.EMSGID      `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	MultiResultRecall *MultiResultRecall `protobuf:"bytes,2,opt,name=multi_result_recall,json=multiResultRecall,proto3" json:"multi_result_recall,omitempty"`
}

func (m *BroadcastMultiResult) Reset()         { *m = BroadcastMultiResult{} }
func (m *BroadcastMultiResult) String() string { return proto.CompactTextString(m) }
func (*BroadcastMultiResult) ProtoMessage()    {}
func (*BroadcastMultiResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{10}
}
func (m *BroadcastMultiResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastMultiResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastMultiResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastMultiResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastMultiResult.Merge(m, src)
}
func (m *BroadcastMultiResult) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastMultiResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastMultiResult.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastMultiResult proto.InternalMessageInfo

func (m *BroadcastMultiResult) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *BroadcastMultiResult) GetMultiResultRecall() *MultiResultRecall {
	if m != nil {
		return m.MultiResultRecall
	}
	return nil
}

type OptionCall struct {
	Msgid          proto2.EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	OptMode        OPTION_MODE   `protobuf:"varint,2,opt,name=opt_mode,json=optMode,proto3,enum=probability.proto.OPTION_MODE" json:"opt_mode,omitempty"`
	Token          string        `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	RoomUuid       string        `protobuf:"bytes,4,opt,name=room_uuid,json=roomUuid,proto3" json:"room_uuid,omitempty"`
	SeatId         int32         `protobuf:"varint,5,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	BonusUuid      string        `protobuf:"bytes,6,opt,name=bonus_uuid,json=bonusUuid,proto3" json:"bonus_uuid,omitempty"`
	PlayerOptIndex int32         `protobuf:"varint,7,opt,name=player_opt_index,json=playerOptIndex,proto3" json:"player_opt_index,omitempty"`
}

func (m *OptionCall) Reset()         { *m = OptionCall{} }
func (m *OptionCall) String() string { return proto.CompactTextString(m) }
func (*OptionCall) ProtoMessage()    {}
func (*OptionCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{11}
}
func (m *OptionCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptionCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptionCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionCall.Merge(m, src)
}
func (m *OptionCall) XXX_Size() int {
	return m.Size()
}
func (m *OptionCall) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionCall.DiscardUnknown(m)
}

var xxx_messageInfo_OptionCall proto.InternalMessageInfo

func (m *OptionCall) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *OptionCall) GetOptMode() OPTION_MODE {
	if m != nil {
		return m.OptMode
	}
	return OPTION_MODE_eGetSelectRedEnvelopeOption
}

func (m *OptionCall) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *OptionCall) GetRoomUuid() string {
	if m != nil {
		return m.RoomUuid
	}
	return ""
}

func (m *OptionCall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *OptionCall) GetBonusUuid() string {
	if m != nil {
		return m.BonusUuid
	}
	return ""
}

func (m *OptionCall) GetPlayerOptIndex() int32 {
	if m != nil {
		return m.PlayerOptIndex
	}
	return 0
}

type OptionRecall struct {
	Msgid          proto2.EMSGID      `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	StatusCode     proto2.Status_Code `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3,enum=common.proto.Status_Code" json:"status_code,omitempty"`
	RoomUuid       string             `protobuf:"bytes,3,opt,name=room_uuid,json=roomUuid,proto3" json:"room_uuid,omitempty"`
	SeatId         int32              `protobuf:"varint,4,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	BonusUuid      string             `protobuf:"bytes,5,opt,name=bonus_uuid,json=bonusUuid,proto3" json:"bonus_uuid,omitempty"`
	PlayerOptIndex int32              `protobuf:"varint,6,opt,name=player_opt_index,json=playerOptIndex,proto3" json:"player_opt_index,omitempty"`
	SymbolId       []int32            `protobuf:"varint,7,rep,packed,name=symbol_id,json=symbolId,proto3" json:"symbol_id,omitempty"`
	AllPay         []int64            `protobuf:"varint,8,rep,packed,name=all_pay,json=allPay,proto3" json:"all_pay,omitempty"`
	HitResult      *HitResult         `protobuf:"bytes,9,opt,name=hit_result,json=hitResult,proto3" json:"hit_result,omitempty"`
}

func (m *OptionRecall) Reset()         { *m = OptionRecall{} }
func (m *OptionRecall) String() string { return proto.CompactTextString(m) }
func (*OptionRecall) ProtoMessage()    {}
func (*OptionRecall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{12}
}
func (m *OptionRecall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionRecall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptionRecall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptionRecall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionRecall.Merge(m, src)
}
func (m *OptionRecall) XXX_Size() int {
	return m.Size()
}
func (m *OptionRecall) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionRecall.DiscardUnknown(m)
}

var xxx_messageInfo_OptionRecall proto.InternalMessageInfo

func (m *OptionRecall) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *OptionRecall) GetStatusCode() proto2.Status_Code {
	if m != nil {
		return m.StatusCode
	}
	return proto2.Status_kSuccess
}

func (m *OptionRecall) GetRoomUuid() string {
	if m != nil {
		return m.RoomUuid
	}
	return ""
}

func (m *OptionRecall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *OptionRecall) GetBonusUuid() string {
	if m != nil {
		return m.BonusUuid
	}
	return ""
}

func (m *OptionRecall) GetPlayerOptIndex() int32 {
	if m != nil {
		return m.PlayerOptIndex
	}
	return 0
}

func (m *OptionRecall) GetSymbolId() []int32 {
	if m != nil {
		return m.SymbolId
	}
	return nil
}

func (m *OptionRecall) GetAllPay() []int64 {
	if m != nil {
		return m.AllPay
	}
	return nil
}

func (m *OptionRecall) GetHitResult() *HitResult {
	if m != nil {
		return m.HitResult
	}
	return nil
}

type BroadcastOption struct {
	Msgid        proto2.EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.proto.EMSGID" json:"msgid,omitempty"`
	OptionRecall *OptionRecall `protobuf:"bytes,2,opt,name=option_recall,json=optionRecall,proto3" json:"option_recall,omitempty"`
}

func (m *BroadcastOption) Reset()         { *m = BroadcastOption{} }
func (m *BroadcastOption) String() string { return proto.CompactTextString(m) }
func (*BroadcastOption) ProtoMessage()    {}
func (*BroadcastOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{13}
}
func (m *BroadcastOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastOption.Merge(m, src)
}
func (m *BroadcastOption) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastOption) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastOption.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastOption proto.InternalMessageInfo

func (m *BroadcastOption) GetMsgid() proto2.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto2.EMSGID_eReserved
}

func (m *BroadcastOption) GetOptionRecall() *OptionRecall {
	if m != nil {
		return m.OptionRecall
	}
	return nil
}

type MercenaryOpenCall struct {
	Msgid         proto1.EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.fish.proto.EMSGID" json:"msgid,omitempty"`
	RoomUuid      string        `protobuf:"bytes,2,opt,name=room_uuid,json=roomUuid,proto3" json:"room_uuid,omitempty"`
	SeatId        int32         `protobuf:"varint,3,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	MercenaryType uint64        `protobuf:"varint,4,opt,name=mercenary_type,json=mercenaryType,proto3" json:"mercenary_type,omitempty"`
	Bullet        uint64        `protobuf:"varint,5,opt,name=bullet,proto3" json:"bullet,omitempty"`
}

func (m *MercenaryOpenCall) Reset()         { *m = MercenaryOpenCall{} }
func (m *MercenaryOpenCall) String() string { return proto.CompactTextString(m) }
func (*MercenaryOpenCall) ProtoMessage()    {}
func (*MercenaryOpenCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{14}
}
func (m *MercenaryOpenCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MercenaryOpenCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MercenaryOpenCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MercenaryOpenCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MercenaryOpenCall.Merge(m, src)
}
func (m *MercenaryOpenCall) XXX_Size() int {
	return m.Size()
}
func (m *MercenaryOpenCall) XXX_DiscardUnknown() {
	xxx_messageInfo_MercenaryOpenCall.DiscardUnknown(m)
}

var xxx_messageInfo_MercenaryOpenCall proto.InternalMessageInfo

func (m *MercenaryOpenCall) GetMsgid() proto1.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto1.EMSGID_eReserved
}

func (m *MercenaryOpenCall) GetRoomUuid() string {
	if m != nil {
		return m.RoomUuid
	}
	return ""
}

func (m *MercenaryOpenCall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *MercenaryOpenCall) GetMercenaryType() uint64 {
	if m != nil {
		return m.MercenaryType
	}
	return 0
}

func (m *MercenaryOpenCall) GetBullet() uint64 {
	if m != nil {
		return m.Bullet
	}
	return 0
}

type MercenaryOpenRecall struct {
	Msgid            proto1.EMSGID      `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.fish.proto.EMSGID" json:"msgid,omitempty"`
	StatusCode       proto2.Status_Code `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3,enum=common.proto.Status_Code" json:"status_code,omitempty"`
	SeatId           int32              `protobuf:"varint,3,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	BulletCollection uint64             `protobuf:"varint,4,opt,name=bullet_collection,json=bulletCollection,proto3" json:"bullet_collection,omitempty"`
	MercenaryType    uint64             `protobuf:"varint,5,opt,name=mercenary_type,json=mercenaryType,proto3" json:"mercenary_type,omitempty"`
	MercenaryBullet  uint64             `protobuf:"varint,6,opt,name=mercenary_bullet,json=mercenaryBullet,proto3" json:"mercenary_bullet,omitempty"`
}

func (m *MercenaryOpenRecall) Reset()         { *m = MercenaryOpenRecall{} }
func (m *MercenaryOpenRecall) String() string { return proto.CompactTextString(m) }
func (*MercenaryOpenRecall) ProtoMessage()    {}
func (*MercenaryOpenRecall) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfb280e9f7669246, []int{15}
}
func (m *MercenaryOpenRecall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MercenaryOpenRecall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MercenaryOpenRecall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MercenaryOpenRecall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MercenaryOpenRecall.Merge(m, src)
}
func (m *MercenaryOpenRecall) XXX_Size() int {
	return m.Size()
}
func (m *MercenaryOpenRecall) XXX_DiscardUnknown() {
	xxx_messageInfo_MercenaryOpenRecall.DiscardUnknown(m)
}

var xxx_messageInfo_MercenaryOpenRecall proto.InternalMessageInfo

func (m *MercenaryOpenRecall) GetMsgid() proto1.EMSGID {
	if m != nil {
		return m.Msgid
	}
	return proto1.EMSGID_eReserved
}

func (m *MercenaryOpenRecall) GetStatusCode() proto2.Status_Code {
	if m != nil {
		return m.StatusCode
	}
	return proto2.Status_kSuccess
}

func (m *MercenaryOpenRecall) GetSeatId() int32 {
	if m != nil {
		return m.SeatId
	}
	return 0
}

func (m *MercenaryOpenRecall) GetBulletCollection() uint64 {
	if m != nil {
		return m.BulletCollection
	}
	return 0
}

func (m *MercenaryOpenRecall) GetMercenaryType() uint64 {
	if m != nil {
		return m.MercenaryType
	}
	return 0
}

func (m *MercenaryOpenRecall) GetMercenaryBullet() uint64 {
	if m != nil {
		return m.MercenaryBullet
	}
	return 0
}

func init() {
	proto.RegisterEnum("probability.proto.OPTION_MODE", OPTION_MODE_name, OPTION_MODE_value)
	proto.RegisterType((*HitFish)(nil), "probability.proto.HitFish")
	proto.RegisterType((*HitBullet)(nil), "probability.proto.HitBullet")
	proto.RegisterType((*HitResult)(nil), "probability.proto.HitResult")
	proto.RegisterType((*TriggerBonus)(nil), "probability.proto.TriggerBonus")
	proto.RegisterType((*ExtraInfo)(nil), "probability.proto.ExtraInfo")
	proto.RegisterType((*ResultCall)(nil), "probability.proto.ResultCall")
	proto.RegisterType((*MultiResultCall)(nil), "probability.proto.MultiResultCall")
	proto.RegisterType((*ResultRecall)(nil), "probability.proto.ResultRecall")
	proto.RegisterType((*MultiResultRecall)(nil), "probability.proto.MultiResultRecall")
	proto.RegisterType((*BroadcastResult)(nil), "probability.proto.BroadcastResult")
	proto.RegisterType((*BroadcastMultiResult)(nil), "probability.proto.BroadcastMultiResult")
	proto.RegisterType((*OptionCall)(nil), "probability.proto.OptionCall")
	proto.RegisterType((*OptionRecall)(nil), "probability.proto.OptionRecall")
	proto.RegisterType((*BroadcastOption)(nil), "probability.proto.BroadcastOption")
	proto.RegisterType((*MercenaryOpenCall)(nil), "probability.proto.MercenaryOpenCall")
	proto.RegisterType((*MercenaryOpenRecall)(nil), "probability.proto.MercenaryOpenRecall")
}

func init() {
	proto.RegisterFile("serve/service_fish/domain/probability/proto/probability.proto", fileDescriptor_bfb280e9f7669246)
}

var fileDescriptor_bfb280e9f7669246 = []byte{
	// 1265 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xcd, 0x8f, 0xdb, 0x44,
	0x14, 0x5f, 0xe7, 0x73, 0xf3, 0x92, 0xfd, 0x72, 0x57, 0xd4, 0xfd, 0x20, 0x8d, 0xac, 0x22, 0x96,
	0xa2, 0x3a, 0x6d, 0x11, 0xaa, 0xa0, 0x12, 0x42, 0xd9, 0x5d, 0xda, 0x88, 0x2e, 0x89, 0xbc, 0xdb,
	0xb3, 0x35, 0xb1, 0xa7, 0xc9, 0xa8, 0x63, 0x8f, 0x65, 0x4f, 0x56, 0xcd, 0x19, 0x21, 0x71, 0xe4,
	0x06, 0xe2, 0xc2, 0x8d, 0x43, 0xff, 0x03, 0xfe, 0x03, 0x8e, 0xe5, 0xc6, 0x11, 0xb5, 0x17, 0xfe,
	0x0c, 0x34, 0x1f, 0xc9, 0xda, 0x8d, 0x97, 0x92, 0x56, 0x42, 0x70, 0xcb, 0xfc, 0xfc, 0xde, 0xcc,
	0x7b, 0xbf, 0xf7, 0xe6, 0x37, 0x2f, 0x70, 0xef, 0x31, 0x49, 0x27, 0x37, 0xc7, 0x28, 0xc4, 0x37,
	0x53, 0x9c, 0x9c, 0xe2, 0xa4, 0x1b, 0xb0, 0x10, 0x91, 0xa8, 0x1b, 0x27, 0x6c, 0x84, 0x46, 0x84,
	0x12, 0x3e, 0x13, 0xbf, 0x39, 0xcb, 0x22, 0x8e, 0x44, 0xcc, 0x9d, 0x25, 0xe8, 0x72, 0x3f, 0x7e,
	0x32, 0xee, 0x86, 0x2c, 0xe8, 0x8e, 0x09, 0xa7, 0x68, 0xe4, 0x90, 0x98, 0xa2, 0x59, 0xca, 0x51,
	0xe2, 0x44, 0x98, 0x77, 0xb3, 0xe7, 0xf8, 0x2c, 0x0c, 0x59, 0xf4, 0xf9, 0xe9, 0x2d, 0xe7, 0xb6,
	0x73, 0x5b, 0x1f, 0xa1, 0x30, 0xbd, 0x55, 0x77, 0x29, 0xb4, 0x90, 0x05, 0x98, 0xa6, 0x39, 0x5b,
	0x4f, 0x18, 0x69, 0x87, 0xcf, 0xce, 0xcb, 0x45, 0x40, 0x09, 0xf6, 0xd9, 0x29, 0x4e, 0xe6, 0xc9,
	0x08, 0xc8, 0x9b, 0x63, 0xca, 0xdf, 0x1e, 0x42, 0xfd, 0x01, 0xe1, 0x5f, 0x90, 0x74, 0x62, 0x9a,
	0x50, 0x99, 0x4e, 0x49, 0x60, 0x19, 0x1d, 0x63, 0xaf, 0xe1, 0xca, 0xdf, 0xe6, 0x15, 0x68, 0xa4,
	0xb3, 0x70, 0xc4, 0xa8, 0x47, 0x02, 0xab, 0xd4, 0x31, 0xf6, 0xaa, 0xee, 0xba, 0x02, 0xfa, 0x81,
	0xb9, 0x0b, 0xd5, 0x84, 0xc7, 0xfd, 0xc0, 0x2a, 0x4b, 0x0f, 0xb5, 0xb0, 0x7f, 0x33, 0xa0, 0xf1,
	0x80, 0xf0, 0xde, 0x94, 0x52, 0xcc, 0xcd, 0x77, 0x01, 0x46, 0x2c, 0x9a, 0xa6, 0x5e, 0x66, 0xeb,
	0x86, 0x44, 0x1e, 0x89, 0xfd, 0xe7, 0x67, 0x96, 0x32, 0x67, 0x5e, 0x84, 0x3a, 0x9f, 0xc5, 0x58,
	0x9c, 0x58, 0x96, 0x27, 0xd6, 0xc4, 0xb2, 0x1f, 0x98, 0xb7, 0xa0, 0xc6, 0x51, 0x32, 0xc6, 0xdc,
	0xaa, 0x74, 0x8c, 0xbd, 0xe6, 0x1d, 0xcb, 0xd1, 0xdc, 0x9d, 0xf1, 0xe1, 0x0c, 0x19, 0x89, 0xb8,
	0xab, 0xed, 0xc4, 0xe9, 0xe9, 0x84, 0x31, 0xee, 0x09, 0x16, 0xad, 0xaa, 0xdc, 0xad, 0x21, 0x91,
	0x23, 0x16, 0x60, 0xf3, 0x7d, 0xd8, 0x42, 0xbe, 0x3f, 0x0d, 0xa7, 0x14, 0x71, 0x1c, 0x78, 0x31,
	0x9a, 0x59, 0xb5, 0x8e, 0xb1, 0x57, 0x71, 0x37, 0x33, 0xf0, 0x10, 0xcd, 0xec, 0x67, 0x2a, 0x27,
	0x17, 0xa7, 0x53, 0xca, 0xcd, 0x6d, 0x28, 0x0b, 0x53, 0x43, 0x9a, 0x8a, 0x9f, 0x66, 0x1b, 0x20,
	0x9c, 0x52, 0x4e, 0x62, 0x4a, 0x70, 0xa2, 0x79, 0xca, 0x20, 0xe6, 0x35, 0x68, 0x8a, 0x9e, 0xc0,
	0x89, 0xe7, 0xe3, 0x88, 0xcb, 0xb4, 0x2a, 0x2e, 0x28, 0x68, 0x1f, 0x47, 0x8a, 0x26, 0x49, 0x98,
	0x0c, 0xa2, 0x22, 0xbf, 0x37, 0x14, 0x32, 0x44, 0x33, 0xf3, 0x43, 0xd8, 0xd1, 0x9f, 0x7d, 0x46,
	0x29, 0xf6, 0x39, 0x61, 0x91, 0x4c, 0xa7, 0xe2, 0x6e, 0xab, 0x0f, 0xfb, 0x0b, 0xdc, 0xfe, 0xde,
	0x80, 0xd6, 0x49, 0x42, 0xc6, 0x63, 0x9c, 0xf4, 0x04, 0xd1, 0x85, 0x85, 0xcd, 0x90, 0x5c, 0xca,
	0x91, 0xbc, 0x0b, 0x55, 0x4e, 0x42, 0x9c, 0x6a, 0xee, 0xd5, 0xc2, 0x3c, 0x80, 0x4d, 0x59, 0xb4,
	0xc3, 0xa7, 0x3c, 0x41, 0xfd, 0xe8, 0x31, 0xd3, 0x25, 0xb8, 0xea, 0x2c, 0x5d, 0x07, 0x67, 0x61,
	0xe3, 0xbe, 0xe2, 0x63, 0x0f, 0xa0, 0xb1, 0x58, 0x98, 0x57, 0x41, 0xf5, 0xc1, 0x10, 0xcd, 0x52,
	0xcb, 0xe8, 0x94, 0x45, 0x69, 0x16, 0x80, 0x79, 0x1d, 0x36, 0xe4, 0xe2, 0x21, 0xf3, 0x91, 0xcc,
	0xb6, 0x24, 0x2d, 0xf2, 0xa0, 0xfd, 0x53, 0x09, 0x40, 0x15, 0x65, 0x1f, 0x51, 0x6a, 0xde, 0x80,
	0x6a, 0x98, 0x8e, 0x75, 0xa6, 0x9b, 0x77, 0x76, 0x9d, 0xec, 0xdd, 0x72, 0x0e, 0x8f, 0x8e, 0xef,
	0xf7, 0x0f, 0x5c, 0x65, 0x22, 0xf3, 0x64, 0x4f, 0x70, 0xa4, 0x5b, 0x4f, 0x2d, 0x44, 0xbf, 0x27,
	0x8c, 0x85, 0xaa, 0x5b, 0x55, 0x5b, 0xaf, 0x0b, 0xe0, 0x91, 0xe6, 0x2c, 0xc5, 0x88, 0x0b, 0xce,
	0x2a, 0x8a, 0x33, 0xb1, 0xec, 0x07, 0xe6, 0xc7, 0xb0, 0x3e, 0x21, 0x5c, 0x5e, 0x4b, 0x59, 0x95,
	0xe6, 0x9d, 0xcb, 0x05, 0xbc, 0xe8, 0x7b, 0xe6, 0xd6, 0x27, 0xfa, 0xc2, 0xdd, 0x03, 0x10, 0x6e,
	0xaa, 0x80, 0xb2, 0xf3, 0x8a, 0x09, 0x5d, 0xdc, 0x26, 0xb7, 0x31, 0x59, 0x5c, 0xac, 0xf7, 0x60,
	0x33, 0xc4, 0x89, 0x8f, 0x23, 0x94, 0xcc, 0x3c, 0x51, 0x3b, 0xab, 0x2e, 0x63, 0xda, 0x58, 0xa0,
	0x27, 0xb3, 0x18, 0xdb, 0xcf, 0x4a, 0xb0, 0x75, 0x24, 0x1a, 0xf1, 0x3f, 0x40, 0xd3, 0x3d, 0x68,
	0xce, 0x69, 0x22, 0x38, 0xb5, 0xaa, 0x9d, 0xf2, 0x6b, 0x98, 0x02, 0xcd, 0x14, 0xc1, 0xe9, 0xbf,
	0x42, 0xd6, 0xcf, 0x55, 0x68, 0x29, 0x9e, 0x5c, 0xec, 0xaf, 0xca, 0xd4, 0xa7, 0xd0, 0x4c, 0x39,
	0xe2, 0xd3, 0xd4, 0xf3, 0x85, 0xd8, 0x94, 0xa4, 0xc7, 0xa5, 0xbc, 0xc7, 0xb1, 0x34, 0x70, 0xf6,
	0x59, 0x80, 0x5d, 0x50, 0xd6, 0xe2, 0xf7, 0x1b, 0xf2, 0xd9, 0x83, 0x8d, 0x11, 0xe6, 0x5e, 0x82,
	0x38, 0xf6, 0x28, 0x89, 0xb0, 0xee, 0xbd, 0x76, 0x81, 0x2c, 0xf6, 0x30, 0x77, 0x11, 0xc7, 0x0f,
	0x49, 0x84, 0xdd, 0xe6, 0xe8, 0x6c, 0x91, 0x6b, 0xdd, 0xda, 0x9b, 0xb6, 0x6e, 0x7d, 0xb5, 0x6a,
	0x68, 0xe7, 0x44, 0x32, 0x6d, 0xad, 0xff, 0x9d, 0xb3, 0xae, 0x86, 0x70, 0xd6, 0xe2, 0x7b, 0x00,
	0x1b, 0x5c, 0x89, 0x9b, 0x27, 0xb5, 0xc0, 0x6a, 0x48, 0xff, 0x6b, 0x05, 0xfe, 0x59, 0x11, 0x74,
	0x5b, 0x3c, 0x2b, 0x89, 0x03, 0xb8, 0x80, 0x85, 0x12, 0x79, 0xf9, 0xbd, 0x40, 0xb6, 0xe4, 0x6b,
	0xf7, 0xda, 0x91, 0xbe, 0x39, 0x8d, 0x3d, 0xcc, 0x76, 0x18, 0x11, 0x02, 0xd9, 0xd4, 0xc5, 0x10,
	0xaf, 0xae, 0x93, 0x7f, 0x75, 0x9d, 0xa3, 0xb9, 0x69, 0xa6, 0x03, 0xa5, 0x28, 0x2e, 0x37, 0x6a,
	0xab, 0xa8, 0x51, 0xbf, 0x31, 0x60, 0x27, 0x73, 0xab, 0xdf, 0xa0, 0x5b, 0x0f, 0x60, 0x43, 0xf1,
	0x2f, 0x06, 0x02, 0x44, 0xa9, 0xd4, 0xd7, 0xe2, 0xd4, 0xb3, 0x67, 0xb8, 0xad, 0x24, 0xb3, 0xb2,
	0xbf, 0x36, 0x60, 0xab, 0x97, 0x30, 0x14, 0xf8, 0x28, 0x9d, 0x17, 0xe8, 0x2d, 0xa3, 0x30, 0x56,
	0x8f, 0xe2, 0x07, 0x03, 0x76, 0x17, 0x51, 0x64, 0x68, 0x59, 0x29, 0x94, 0x13, 0xb8, 0x20, 0x1f,
	0x6c, 0xaf, 0x28, 0xa0, 0xeb, 0x05, 0x01, 0x2d, 0xf1, 0xef, 0xee, 0x84, 0xaf, 0x42, 0xf6, 0xb7,
	0x25, 0x80, 0x41, 0x2c, 0xde, 0xaa, 0x95, 0x95, 0xf7, 0x13, 0x58, 0x67, 0xb1, 0x9e, 0x5c, 0x94,
	0x98, 0xb4, 0x0b, 0xa2, 0x18, 0x0c, 0x4f, 0xfa, 0x83, 0xaf, 0xbc, 0xa3, 0xc1, 0xc1, 0xa1, 0x5b,
	0x67, 0xb1, 0x9a, 0x6b, 0x16, 0xa2, 0x5d, 0x3e, 0x57, 0xb4, 0x2b, 0xe7, 0x8b, 0x4c, 0x35, 0x27,
	0x32, 0xf9, 0x01, 0xae, 0xf6, 0xea, 0x00, 0xb7, 0x07, 0xdb, 0x7a, 0xb2, 0x11, 0xc1, 0x92, 0x28,
	0xc0, 0x4f, 0xb5, 0xb6, 0x6e, 0x2a, 0x7c, 0x10, 0xf3, 0xbe, 0x40, 0xed, 0x3f, 0x4b, 0xd0, 0x52,
	0x54, 0xfc, 0x2f, 0xc4, 0x35, 0x9f, 0x77, 0xf5, 0x9f, 0xe4, 0x5d, 0x2b, 0xca, 0x3b, 0x3f, 0x42,
	0xd7, 0xe5, 0x14, 0x73, 0x36, 0x42, 0x5f, 0x84, 0x3a, 0xa2, 0x54, 0x0e, 0x7d, 0xeb, 0x9d, 0xf2,
	0x5e, 0xd9, 0xad, 0x21, 0x4a, 0xc5, 0xc4, 0x97, 0xd7, 0xc8, 0xc6, 0x4a, 0x1a, 0x99, 0xbf, 0x96,
	0x8a, 0xf3, 0x55, 0xaf, 0x25, 0x93, 0x5e, 0xaf, 0xbf, 0x96, 0xd9, 0x8a, 0xba, 0x2d, 0x96, 0x59,
	0xd9, 0xbf, 0x08, 0x91, 0x9a, 0xcb, 0xd6, 0x20, 0xc6, 0xea, 0x0a, 0x74, 0xf3, 0x71, 0x5c, 0x2a,
	0x78, 0xac, 0xf2, 0xc1, 0xe4, 0xca, 0x57, 0x3a, 0xbf, 0x7c, 0xe5, 0x5c, 0xf9, 0x96, 0x85, 0x54,
	0x0d, 0xd5, 0x79, 0x21, 0x35, 0xdf, 0x81, 0x9a, 0x7e, 0xc3, 0xd4, 0x34, 0xad, 0x57, 0xf6, 0x8f,
	0x25, 0xb8, 0x90, 0x8b, 0x5d, 0xf7, 0xec, 0xca, 0xd1, 0xbf, 0x4d, 0xe3, 0x9e, 0x9b, 0x5c, 0xe1,
	0xdf, 0x81, 0x4a, 0xf1, 0xdf, 0x81, 0x02, 0x26, 0xaa, 0x45, 0x4c, 0x7c, 0x00, 0xdb, 0x67, 0x66,
	0x99, 0x29, 0xab, 0xe2, 0x6e, 0x2d, 0x70, 0xf5, 0x7e, 0xdf, 0xf8, 0x12, 0x9a, 0x19, 0xd9, 0x31,
	0xaf, 0xc1, 0x15, 0x7c, 0x1f, 0xf3, 0x63, 0x2c, 0x4e, 0x74, 0x71, 0x70, 0x18, 0x9d, 0x62, 0xca,
	0x62, 0xac, 0x5a, 0x63, 0x7b, 0xcd, 0xbc, 0x02, 0x17, 0xcf, 0x0c, 0x8e, 0x29, 0xe3, 0x77, 0xef,
	0xde, 0xd5, 0x1f, 0x8d, 0x9e, 0xf5, 0xeb, 0x8b, 0xb6, 0xf1, 0xfc, 0x45, 0xdb, 0xf8, 0xe3, 0x45,
	0xdb, 0xf8, 0xee, 0x65, 0x7b, 0xed, 0xf9, 0xcb, 0xf6, 0xda, 0xef, 0x2f, 0xdb, 0x6b, 0xa3, 0x9a,
	0x64, 0xe7, 0xa3, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x85, 0xd1, 0xc5, 0x72, 0xaf, 0x0f, 0x00,
	0x00,
}

func (m *HitFish) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HitFish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HitFish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RtpId) > 0 {
		i -= len(m.RtpId)
		copy(dAtA[i:], m.RtpId)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RtpId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SymbolId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SymbolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HitBullet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HitBullet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HitBullet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccumulatedPay != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.AccumulatedPay))
		i--
		dAtA[i] = 0x30
	}
	if m.ShootMode != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.ShootMode))
		i--
		dAtA[i] = 0x28
	}
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TypeId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.TypeId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BonusUuid) > 0 {
		i -= len(m.BonusUuid)
		copy(dAtA[i:], m.BonusUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.BonusUuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HitResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HitResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HitResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BulletCollection != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.BulletCollection))
		i--
		dAtA[i] = 0x28
	}
	if m.BulletPay != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.BulletPay))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerCent != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.PlayerCent))
		i--
		dAtA[i] = 0x18
	}
	if m.Multiplier != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Multiplier))
		i--
		dAtA[i] = 0x10
	}
	if m.Pay != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Pay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerBonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerBonus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerBonus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BonusExtraInfo != nil {
		{
			size, err := m.BonusExtraInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Times != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x18
	}
	if m.TypeId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.TypeId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtraInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtraInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BonusLocation) > 0 {
		dAtA4 := make([]byte, len(m.BonusLocation)*10)
		var j3 int
		for _, num1 := range m.BonusLocation {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintProbability(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BonusPays) > 0 {
		dAtA6 := make([]byte, len(m.BonusPays)*10)
		var j5 int
		for _, num1 := range m.BonusPays {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintProbability(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResultCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MercenaryType != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.MercenaryType))
		i--
		dAtA[i] = 0x38
	}
	if m.HitBullet != nil {
		{
			size, err := m.HitBullet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.HitFish != nil {
		{
			size, err := m.HitFish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoomUuid) > 0 {
		i -= len(m.RoomUuid)
		copy(dAtA[i:], m.RoomUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RoomUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiResultCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiResultCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiResultCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MercenaryType != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.MercenaryType))
		i--
		dAtA[i] = 0x38
	}
	if m.HitBullet != nil {
		{
			size, err := m.HitBullet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.HitFishies) > 0 {
		for iNdEx := len(m.HitFishies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HitFishies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProbability(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoomUuid) > 0 {
		i -= len(m.RoomUuid)
		copy(dAtA[i:], m.RoomUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RoomUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultRecall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultRecall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultRecall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MercenaryType != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.MercenaryType))
		i--
		dAtA[i] = 0x60
	}
	if m.MercenaryInfo != nil {
		{
			size, err := m.MercenaryInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ExtraTriggerBonus) > 0 {
		for iNdEx := len(m.ExtraTriggerBonus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraTriggerBonus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProbability(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.TriggerBonus != nil {
		{
			size, err := m.TriggerBonus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.HitResult != nil {
		{
			size, err := m.HitResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.HitBullet != nil {
		{
			size, err := m.HitBullet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.HitFish != nil {
		{
			size, err := m.HitFish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BetRateLine != nil {
		{
			size, err := m.BetRateLine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoomUuid) > 0 {
		i -= len(m.RoomUuid)
		copy(dAtA[i:], m.RoomUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RoomUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusCode != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiResultRecall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiResultRecall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiResultRecall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResultRecall) > 0 {
		for iNdEx := len(m.ResultRecall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResultRecall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProbability(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResultRecall != nil {
		{
			size, err := m.ResultRecall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastMultiResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastMultiResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastMultiResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MultiResultRecall != nil {
		{
			size, err := m.MultiResultRecall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OptionCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerOptIndex != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.PlayerOptIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BonusUuid) > 0 {
		i -= len(m.BonusUuid)
		copy(dAtA[i:], m.BonusUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.BonusUuid)))
		i--
		dAtA[i] = 0x32
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RoomUuid) > 0 {
		i -= len(m.RoomUuid)
		copy(dAtA[i:], m.RoomUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RoomUuid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OptMode != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.OptMode))
		i--
		dAtA[i] = 0x10
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OptionRecall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionRecall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionRecall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HitResult != nil {
		{
			size, err := m.HitResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AllPay) > 0 {
		dAtA20 := make([]byte, len(m.AllPay)*10)
		var j19 int
		for _, num1 := range m.AllPay {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintProbability(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SymbolId) > 0 {
		dAtA22 := make([]byte, len(m.SymbolId)*10)
		var j21 int
		for _, num1 := range m.SymbolId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintProbability(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x3a
	}
	if m.PlayerOptIndex != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.PlayerOptIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BonusUuid) > 0 {
		i -= len(m.BonusUuid)
		copy(dAtA[i:], m.BonusUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.BonusUuid)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoomUuid) > 0 {
		i -= len(m.RoomUuid)
		copy(dAtA[i:], m.RoomUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RoomUuid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusCode != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptionRecall != nil {
		{
			size, err := m.OptionRecall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProbability(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MercenaryOpenCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MercenaryOpenCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MercenaryOpenCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bullet != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Bullet))
		i--
		dAtA[i] = 0x28
	}
	if m.MercenaryType != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.MercenaryType))
		i--
		dAtA[i] = 0x20
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RoomUuid) > 0 {
		i -= len(m.RoomUuid)
		copy(dAtA[i:], m.RoomUuid)
		i = encodeVarintProbability(dAtA, i, uint64(len(m.RoomUuid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MercenaryOpenRecall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MercenaryOpenRecall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MercenaryOpenRecall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MercenaryBullet != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.MercenaryBullet))
		i--
		dAtA[i] = 0x30
	}
	if m.MercenaryType != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.MercenaryType))
		i--
		dAtA[i] = 0x28
	}
	if m.BulletCollection != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.BulletCollection))
		i--
		dAtA[i] = 0x20
	}
	if m.SeatId != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.SeatId))
		i--
		dAtA[i] = 0x18
	}
	if m.StatusCode != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Msgid != 0 {
		i = encodeVarintProbability(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProbability(dAtA []byte, offset int, v uint64) int {
	offset -= sovProbability(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HitFish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SymbolId != 0 {
		n += 1 + sovProbability(uint64(m.SymbolId))
	}
	l = len(m.RtpId)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	return n
}

func (m *HitBullet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BonusUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.TypeId != 0 {
		n += 1 + sovProbability(uint64(m.TypeId))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.ShootMode != 0 {
		n += 1 + sovProbability(uint64(m.ShootMode))
	}
	if m.AccumulatedPay != 0 {
		n += 1 + sovProbability(uint64(m.AccumulatedPay))
	}
	return n
}

func (m *HitResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pay != 0 {
		n += 1 + sovProbability(uint64(m.Pay))
	}
	if m.Multiplier != 0 {
		n += 1 + sovProbability(uint64(m.Multiplier))
	}
	if m.PlayerCent != 0 {
		n += 1 + sovProbability(uint64(m.PlayerCent))
	}
	if m.BulletPay != 0 {
		n += 1 + sovProbability(uint64(m.BulletPay))
	}
	if m.BulletCollection != 0 {
		n += 1 + sovProbability(uint64(m.BulletCollection))
	}
	return n
}

func (m *TriggerBonus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.TypeId != 0 {
		n += 1 + sovProbability(uint64(m.TypeId))
	}
	if m.Times != 0 {
		n += 1 + sovProbability(uint64(m.Times))
	}
	if m.BonusExtraInfo != nil {
		l = m.BonusExtraInfo.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	return n
}

func (m *ExtraInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BonusPays) > 0 {
		l = 0
		for _, e := range m.BonusPays {
			l += sovProbability(uint64(e))
		}
		n += 1 + sovProbability(uint64(l)) + l
	}
	if len(m.BonusLocation) > 0 {
		l = 0
		for _, e := range m.BonusLocation {
			l += sovProbability(uint64(e))
		}
		n += 1 + sovProbability(uint64(l)) + l
	}
	return n
}

func (m *ResultCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	l = len(m.RoomUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	if m.HitFish != nil {
		l = m.HitFish.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.HitBullet != nil {
		l = m.HitBullet.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.MercenaryType != 0 {
		n += 1 + sovProbability(uint64(m.MercenaryType))
	}
	return n
}

func (m *MultiResultCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	l = len(m.RoomUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	if len(m.HitFishies) > 0 {
		for _, e := range m.HitFishies {
			l = e.Size()
			n += 1 + l + sovProbability(uint64(l))
		}
	}
	if m.HitBullet != nil {
		l = m.HitBullet.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.MercenaryType != 0 {
		n += 1 + sovProbability(uint64(m.MercenaryType))
	}
	return n
}

func (m *ResultRecall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.StatusCode != 0 {
		n += 1 + sovProbability(uint64(m.StatusCode))
	}
	l = len(m.RoomUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	if m.BetRateLine != nil {
		l = m.BetRateLine.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.HitFish != nil {
		l = m.HitFish.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.HitBullet != nil {
		l = m.HitBullet.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.HitResult != nil {
		l = m.HitResult.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.TriggerBonus != nil {
		l = m.TriggerBonus.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if len(m.ExtraTriggerBonus) > 0 {
		for _, e := range m.ExtraTriggerBonus {
			l = e.Size()
			n += 1 + l + sovProbability(uint64(l))
		}
	}
	if m.MercenaryInfo != nil {
		l = m.MercenaryInfo.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.MercenaryType != 0 {
		n += 1 + sovProbability(uint64(m.MercenaryType))
	}
	return n
}

func (m *MultiResultRecall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if len(m.ResultRecall) > 0 {
		for _, e := range m.ResultRecall {
			l = e.Size()
			n += 1 + l + sovProbability(uint64(l))
		}
	}
	return n
}

func (m *BroadcastResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.ResultRecall != nil {
		l = m.ResultRecall.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	return n
}

func (m *BroadcastMultiResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.MultiResultRecall != nil {
		l = m.MultiResultRecall.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	return n
}

func (m *OptionCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.OptMode != 0 {
		n += 1 + sovProbability(uint64(m.OptMode))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	l = len(m.RoomUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	l = len(m.BonusUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.PlayerOptIndex != 0 {
		n += 1 + sovProbability(uint64(m.PlayerOptIndex))
	}
	return n
}

func (m *OptionRecall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.StatusCode != 0 {
		n += 1 + sovProbability(uint64(m.StatusCode))
	}
	l = len(m.RoomUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	l = len(m.BonusUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.PlayerOptIndex != 0 {
		n += 1 + sovProbability(uint64(m.PlayerOptIndex))
	}
	if len(m.SymbolId) > 0 {
		l = 0
		for _, e := range m.SymbolId {
			l += sovProbability(uint64(e))
		}
		n += 1 + sovProbability(uint64(l)) + l
	}
	if len(m.AllPay) > 0 {
		l = 0
		for _, e := range m.AllPay {
			l += sovProbability(uint64(e))
		}
		n += 1 + sovProbability(uint64(l)) + l
	}
	if m.HitResult != nil {
		l = m.HitResult.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	return n
}

func (m *BroadcastOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.OptionRecall != nil {
		l = m.OptionRecall.Size()
		n += 1 + l + sovProbability(uint64(l))
	}
	return n
}

func (m *MercenaryOpenCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	l = len(m.RoomUuid)
	if l > 0 {
		n += 1 + l + sovProbability(uint64(l))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	if m.MercenaryType != 0 {
		n += 1 + sovProbability(uint64(m.MercenaryType))
	}
	if m.Bullet != 0 {
		n += 1 + sovProbability(uint64(m.Bullet))
	}
	return n
}

func (m *MercenaryOpenRecall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovProbability(uint64(m.Msgid))
	}
	if m.StatusCode != 0 {
		n += 1 + sovProbability(uint64(m.StatusCode))
	}
	if m.SeatId != 0 {
		n += 1 + sovProbability(uint64(m.SeatId))
	}
	if m.BulletCollection != 0 {
		n += 1 + sovProbability(uint64(m.BulletCollection))
	}
	if m.MercenaryType != 0 {
		n += 1 + sovProbability(uint64(m.MercenaryType))
	}
	if m.MercenaryBullet != 0 {
		n += 1 + sovProbability(uint64(m.MercenaryBullet))
	}
	return n
}

func sovProbability(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProbability(x uint64) (n int) {
	return sovProbability(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HitFish) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HitFish: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HitFish: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolId", wireType)
			}
			m.SymbolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SymbolId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RtpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HitBullet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HitBullet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HitBullet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BonusUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &proto1.Point{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShootMode", wireType)
			}
			m.ShootMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShootMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedPay", wireType)
			}
			m.AccumulatedPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccumulatedPay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HitResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HitResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HitResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			m.Pay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			m.Multiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiplier |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerCent", wireType)
			}
			m.PlayerCent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerCent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletPay", wireType)
			}
			m.BulletPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BulletPay |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletCollection", wireType)
			}
			m.BulletCollection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BulletCollection |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerBonus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerBonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerBonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusExtraInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BonusExtraInfo == nil {
				m.BonusExtraInfo = &ExtraInfo{}
			}
			if err := m.BonusExtraInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BonusPays = append(m.BonusPays, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProbability
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProbability
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BonusPays) == 0 {
					m.BonusPays = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProbability
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BonusPays = append(m.BonusPays, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusPays", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BonusLocation = append(m.BonusLocation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProbability
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProbability
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BonusLocation) == 0 {
					m.BonusLocation = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProbability
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BonusLocation = append(m.BonusLocation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusLocation", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitFish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitFish == nil {
				m.HitFish = &HitFish{}
			}
			if err := m.HitFish.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitBullet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitBullet == nil {
				m.HitBullet = &HitBullet{}
			}
			if err := m.HitBullet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryType", wireType)
			}
			m.MercenaryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MercenaryType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiResultCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiResultCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiResultCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitFishies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HitFishies = append(m.HitFishies, &HitFish{})
			if err := m.HitFishies[len(m.HitFishies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitBullet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitBullet == nil {
				m.HitBullet = &HitBullet{}
			}
			if err := m.HitBullet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryType", wireType)
			}
			m.MercenaryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MercenaryType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultRecall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultRecall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultRecall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= proto2.Status_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetRateLine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BetRateLine == nil {
				m.BetRateLine = &proto1.BetRateLine{}
			}
			if err := m.BetRateLine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitFish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitFish == nil {
				m.HitFish = &HitFish{}
			}
			if err := m.HitFish.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitBullet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitBullet == nil {
				m.HitBullet = &HitBullet{}
			}
			if err := m.HitBullet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitResult == nil {
				m.HitResult = &HitResult{}
			}
			if err := m.HitResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerBonus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerBonus == nil {
				m.TriggerBonus = &TriggerBonus{}
			}
			if err := m.TriggerBonus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraTriggerBonus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraTriggerBonus = append(m.ExtraTriggerBonus, &TriggerBonus{})
			if err := m.ExtraTriggerBonus[len(m.ExtraTriggerBonus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MercenaryInfo == nil {
				m.MercenaryInfo = &proto3.Mercenary{}
			}
			if err := m.MercenaryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryType", wireType)
			}
			m.MercenaryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MercenaryType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiResultRecall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiResultRecall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiResultRecall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultRecall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultRecall = append(m.ResultRecall, &ResultRecall{})
			if err := m.ResultRecall[len(m.ResultRecall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultRecall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResultRecall == nil {
				m.ResultRecall = &ResultRecall{}
			}
			if err := m.ResultRecall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastMultiResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastMultiResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastMultiResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiResultRecall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiResultRecall == nil {
				m.MultiResultRecall = &MultiResultRecall{}
			}
			if err := m.MultiResultRecall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptMode", wireType)
			}
			m.OptMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptMode |= OPTION_MODE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BonusUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerOptIndex", wireType)
			}
			m.PlayerOptIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerOptIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptionRecall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionRecall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionRecall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= proto2.Status_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BonusUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerOptIndex", wireType)
			}
			m.PlayerOptIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerOptIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SymbolId = append(m.SymbolId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProbability
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProbability
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SymbolId) == 0 {
					m.SymbolId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProbability
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SymbolId = append(m.SymbolId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolId", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllPay = append(m.AllPay, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProbability
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProbability
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProbability
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllPay) == 0 {
					m.AllPay = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProbability
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllPay = append(m.AllPay, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPay", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitResult == nil {
				m.HitResult = &HitResult{}
			}
			if err := m.HitResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto2.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionRecall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionRecall == nil {
				m.OptionRecall = &OptionRecall{}
			}
			if err := m.OptionRecall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MercenaryOpenCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MercenaryOpenCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MercenaryOpenCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto1.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProbability
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProbability
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryType", wireType)
			}
			m.MercenaryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MercenaryType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bullet", wireType)
			}
			m.Bullet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bullet |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MercenaryOpenRecall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MercenaryOpenRecall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MercenaryOpenRecall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= proto1.EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= proto2.Status_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatId", wireType)
			}
			m.SeatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletCollection", wireType)
			}
			m.BulletCollection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BulletCollection |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryType", wireType)
			}
			m.MercenaryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MercenaryType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MercenaryBullet", wireType)
			}
			m.MercenaryBullet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MercenaryBullet |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProbability(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProbability
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProbability(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProbability
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProbability
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProbability
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProbability
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProbability
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProbability        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProbability          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProbability = fmt.Errorf("proto: unexpected end of group")
)
