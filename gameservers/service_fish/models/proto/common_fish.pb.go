// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: serve/service_fish/models/proto/common_fish.proto

package common_fish_proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EMSGID int32

const (
	EMSGID_eReserved            EMSGID = 0
	EMSGID_eAllFishCall         EMSGID = 3000
	EMSGID_eAllFishRecall       EMSGID = 3001
	EMSGID_eBetChange           EMSGID = 3100
	EMSGID_eBroadcastBetChange  EMSGID = 3101
	EMSGID_eBroadcastShoot      EMSGID = 3102
	EMSGID_eBroadcastFishIn     EMSGID = 3103
	EMSGID_eBroadcastFishOut    EMSGID = 3104
	EMSGID_eBroadcastFishChange EMSGID = 3105
	EMSGID_eBroadcastGroupIn    EMSGID = 3106
	EMSGID_eMercenaryOpenCall   EMSGID = 4200
	EMSGID_eMercenaryOpenRecall EMSGID = 4201
	EMSGID_eRoundStart          EMSGID = 4700
	EMSGID_eRoundEnd            EMSGID = 4701
	EMSGID_eShoot               EMSGID = 4800
)

var EMSGID_name = map[int32]string{
	0:    "eReserved",
	3000: "eAllFishCall",
	3001: "eAllFishRecall",
	3100: "eBetChange",
	3101: "eBroadcastBetChange",
	3102: "eBroadcastShoot",
	3103: "eBroadcastFishIn",
	3104: "eBroadcastFishOut",
	3105: "eBroadcastFishChange",
	3106: "eBroadcastGroupIn",
	4200: "eMercenaryOpenCall",
	4201: "eMercenaryOpenRecall",
	4700: "eRoundStart",
	4701: "eRoundEnd",
	4800: "eShoot",
}

var EMSGID_value = map[string]int32{
	"eReserved":            0,
	"eAllFishCall":         3000,
	"eAllFishRecall":       3001,
	"eBetChange":           3100,
	"eBroadcastBetChange":  3101,
	"eBroadcastShoot":      3102,
	"eBroadcastFishIn":     3103,
	"eBroadcastFishOut":    3104,
	"eBroadcastFishChange": 3105,
	"eBroadcastGroupIn":    3106,
	"eMercenaryOpenCall":   4200,
	"eMercenaryOpenRecall": 4201,
	"eRoundStart":          4700,
	"eRoundEnd":            4701,
	"eShoot":               4800,
}

func (x EMSGID) String() string {
	return proto.EnumName(EMSGID_name, int32(x))
}

func (EMSGID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56867f3cfd612710, []int{0}
}

type Header struct {
	Msgid EMSGID `protobuf:"varint,1,opt,name=msgid,proto3,enum=common.fish.proto.EMSGID" json:"msgid,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_56867f3cfd612710, []int{0}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetMsgid() EMSGID {
	if m != nil {
		return m.Msgid
	}
	return EMSGID_eReserved
}

type BetRateLine struct {
	BetLevelIndex int32 `protobuf:"varint,1,opt,name=bet_level_index,json=betLevelIndex,proto3" json:"bet_level_index,omitempty"`
	BetIndex      int32 `protobuf:"varint,2,opt,name=bet_index,json=betIndex,proto3" json:"bet_index,omitempty"`
	LineIndex     int32 `protobuf:"varint,3,opt,name=line_index,json=lineIndex,proto3" json:"line_index,omitempty"`
	RateIndex     int32 `protobuf:"varint,4,opt,name=rate_index,json=rateIndex,proto3" json:"rate_index,omitempty"`
}

func (m *BetRateLine) Reset()         { *m = BetRateLine{} }
func (m *BetRateLine) String() string { return proto.CompactTextString(m) }
func (*BetRateLine) ProtoMessage()    {}
func (*BetRateLine) Descriptor() ([]byte, []int) {
	return fileDescriptor_56867f3cfd612710, []int{1}
}
func (m *BetRateLine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BetRateLine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BetRateLine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BetRateLine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BetRateLine.Merge(m, src)
}
func (m *BetRateLine) XXX_Size() int {
	return m.Size()
}
func (m *BetRateLine) XXX_DiscardUnknown() {
	xxx_messageInfo_BetRateLine.DiscardUnknown(m)
}

var xxx_messageInfo_BetRateLine proto.InternalMessageInfo

func (m *BetRateLine) GetBetLevelIndex() int32 {
	if m != nil {
		return m.BetLevelIndex
	}
	return 0
}

func (m *BetRateLine) GetBetIndex() int32 {
	if m != nil {
		return m.BetIndex
	}
	return 0
}

func (m *BetRateLine) GetLineIndex() int32 {
	if m != nil {
		return m.LineIndex
	}
	return 0
}

func (m *BetRateLine) GetRateIndex() int32 {
	if m != nil {
		return m.RateIndex
	}
	return 0
}

type Point struct {
	X float64 `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y float64 `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Point) Reset()         { *m = Point{} }
func (m *Point) String() string { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()    {}
func (*Point) Descriptor() ([]byte, []int) {
	return fileDescriptor_56867f3cfd612710, []int{2}
}
func (m *Point) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Point) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Point.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Point) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Point.Merge(m, src)
}
func (m *Point) XXX_Size() int {
	return m.Size()
}
func (m *Point) XXX_DiscardUnknown() {
	xxx_messageInfo_Point.DiscardUnknown(m)
}

var xxx_messageInfo_Point proto.InternalMessageInfo

func (m *Point) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func init() {
	proto.RegisterEnum("common.fish.proto.EMSGID", EMSGID_name, EMSGID_value)
	proto.RegisterType((*Header)(nil), "common.fish.proto.Header")
	proto.RegisterType((*BetRateLine)(nil), "common.fish.proto.BetRateLine")
	proto.RegisterType((*Point)(nil), "common.fish.proto.Point")
}

func init() {
	proto.RegisterFile("serve/service_fish/models/proto/common_fish.proto", fileDescriptor_56867f3cfd612710)
}

var fileDescriptor_56867f3cfd612710 = []byte{
	// 460 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0xdf, 0x6a, 0x13, 0x4d,
	0x18, 0xc6, 0x33, 0xfd, 0xbe, 0x04, 0xf3, 0xa6, 0x4d, 0x26, 0x6f, 0xab, 0xd9, 0x22, 0x2e, 0x21,
	0x56, 0x11, 0xa1, 0x59, 0xd0, 0x23, 0x0f, 0x4d, 0xad, 0x35, 0xd0, 0x52, 0xd9, 0x5c, 0x40, 0x98,
	0x64, 0x5f, 0x93, 0x85, 0xdd, 0x99, 0x30, 0x3b, 0x29, 0xcd, 0x5d, 0xf4, 0x02, 0xfc, 0x7f, 0x15,
	0x7a, 0xe6, 0x89, 0xe0, 0x61, 0x0f, 0x3d, 0x50, 0x90, 0xe4, 0x44, 0xef, 0x42, 0x66, 0x36, 0x35,
	0x44, 0x0f, 0xf7, 0xf7, 0x7b, 0xf6, 0x19, 0x9e, 0x61, 0x20, 0x78, 0x11, 0x67, 0xe3, 0xfd, 0x91,
	0x48, 0x69, 0x3f, 0x23, 0x7d, 0x46, 0x3a, 0x48, 0x55, 0x44, 0x49, 0x16, 0x4c, 0xb4, 0x32, 0x2a,
	0x18, 0xaa, 0x34, 0x55, 0xb2, 0x6f, 0x43, 0x6d, 0x47, 0xb0, 0x9e, 0xa3, 0xf6, 0x0a, 0xb5, 0x1e,
	0x41, 0xe9, 0x19, 0x89, 0x88, 0x34, 0x06, 0x50, 0x4c, 0xb3, 0x51, 0x1c, 0x79, 0xac, 0xc9, 0xee,
	0x55, 0x1f, 0xec, 0xb6, 0xff, 0x09, 0xb7, 0x0f, 0x4f, 0x7a, 0x47, 0xdd, 0x27, 0x61, 0x9e, 0x6b,
	0x5d, 0x30, 0xa8, 0x74, 0xc8, 0x84, 0xc2, 0xd0, 0x71, 0x2c, 0x09, 0xef, 0x42, 0x6d, 0x40, 0xa6,
	0x9f, 0xd0, 0x19, 0x25, 0xfd, 0x58, 0x46, 0x74, 0xee, 0xaa, 0x8a, 0xe1, 0xd6, 0x80, 0xcc, 0xb1,
	0xa5, 0x5d, 0x0b, 0xf1, 0x26, 0x94, 0x6d, 0x2e, 0x4f, 0x6c, 0xb8, 0xc4, 0xb5, 0x01, 0x99, 0x5c,
	0xde, 0x02, 0x48, 0x62, 0x49, 0x4b, 0xfb, 0x9f, 0xb3, 0x65, 0x4b, 0xfe, 0x68, 0x2d, 0xcc, 0x95,
	0xfe, 0x3f, 0xd7, 0x96, 0x38, 0xdd, 0xba, 0x0d, 0xc5, 0xe7, 0x2a, 0x96, 0x06, 0x37, 0x81, 0xe5,
	0xa7, 0xb3, 0x90, 0x9d, 0xdb, 0xaf, 0x99, 0x3b, 0x89, 0x85, 0x6c, 0x76, 0xff, 0xf3, 0x06, 0x94,
	0xf2, 0x25, 0xb8, 0x05, 0x65, 0x0a, 0xc9, 0x5d, 0x5e, 0xc4, 0x0b, 0x58, 0x87, 0x4d, 0x7a, 0x9c,
	0x24, 0x4f, 0xe3, 0x6c, 0x7c, 0x20, 0x92, 0x84, 0x7f, 0x68, 0xe0, 0x36, 0x54, 0xaf, 0x50, 0x48,
	0x43, 0x0b, 0x3f, 0x36, 0xb0, 0x06, 0x40, 0x1d, 0x32, 0x07, 0x63, 0x21, 0x47, 0xc4, 0x5f, 0x7a,
	0xe8, 0xc1, 0x36, 0x75, 0xb4, 0x12, 0xd1, 0x50, 0x64, 0x66, 0x65, 0x5e, 0x79, 0xb8, 0x03, 0xb5,
	0x95, 0xe9, 0x8d, 0x95, 0x32, 0xfc, 0xb5, 0x87, 0xd7, 0x81, 0xaf, 0xa8, 0xed, 0xee, 0x4a, 0xfe,
	0xc6, 0xc3, 0x1b, 0x50, 0x5f, 0xc7, 0xa7, 0x53, 0xc3, 0xdf, 0x7a, 0xb8, 0x0b, 0x3b, 0xeb, 0x7c,
	0xd9, 0xff, 0xee, 0xaf, 0x5f, 0x8e, 0xb4, 0x9a, 0x4e, 0xba, 0x92, 0xbf, 0xf7, 0xb0, 0x01, 0x48,
	0x27, 0xa4, 0x87, 0x24, 0x85, 0x9e, 0x9d, 0x4e, 0x48, 0xba, 0x41, 0x3f, 0x9b, 0xae, 0x6b, 0x4d,
	0x2c, 0x67, 0xfd, 0x6a, 0x22, 0x87, 0x0a, 0x85, 0x6a, 0x2a, 0xa3, 0x9e, 0x11, 0xda, 0xf0, 0x6f,
	0x7b, 0x58, 0xb5, 0xf7, 0x63, 0xc9, 0xa1, 0x8c, 0xf8, 0xf7, 0x3d, 0xac, 0x40, 0x89, 0xf2, 0x11,
	0x9f, 0xee, 0x74, 0xbc, 0x2f, 0x73, 0x9f, 0x5d, 0xce, 0x7d, 0xf6, 0x63, 0xee, 0xb3, 0x8b, 0x85,
	0x5f, 0xb8, 0x5c, 0xf8, 0x85, 0xaf, 0x0b, 0xbf, 0x30, 0x28, 0xb9, 0xe7, 0xf2, 0xf0, 0x77, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x90, 0xd3, 0x64, 0x7a, 0xa1, 0x02, 0x00, 0x00,
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Msgid != 0 {
		i = encodeVarintCommonFish(dAtA, i, uint64(m.Msgid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BetRateLine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetRateLine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BetRateLine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateIndex != 0 {
		i = encodeVarintCommonFish(dAtA, i, uint64(m.RateIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.LineIndex != 0 {
		i = encodeVarintCommonFish(dAtA, i, uint64(m.LineIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.BetIndex != 0 {
		i = encodeVarintCommonFish(dAtA, i, uint64(m.BetIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.BetLevelIndex != 0 {
		i = encodeVarintCommonFish(dAtA, i, uint64(m.BetLevelIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Point) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i--
		dAtA[i] = 0x11
	}
	if m.X != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommonFish(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommonFish(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msgid != 0 {
		n += 1 + sovCommonFish(uint64(m.Msgid))
	}
	return n
}

func (m *BetRateLine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BetLevelIndex != 0 {
		n += 1 + sovCommonFish(uint64(m.BetLevelIndex))
	}
	if m.BetIndex != 0 {
		n += 1 + sovCommonFish(uint64(m.BetIndex))
	}
	if m.LineIndex != 0 {
		n += 1 + sovCommonFish(uint64(m.LineIndex))
	}
	if m.RateIndex != 0 {
		n += 1 + sovCommonFish(uint64(m.RateIndex))
	}
	return n
}

func (m *Point) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	return n
}

func sovCommonFish(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommonFish(x uint64) (n int) {
	return sovCommonFish(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommonFish
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgid", wireType)
			}
			m.Msgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Msgid |= EMSGID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommonFish(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommonFish
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommonFish
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetRateLine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommonFish
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetRateLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetRateLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetLevelIndex", wireType)
			}
			m.BetLevelIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetLevelIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetIndex", wireType)
			}
			m.BetIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineIndex", wireType)
			}
			m.LineIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LineIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateIndex", wireType)
			}
			m.RateIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommonFish(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommonFish
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommonFish
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommonFish
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCommonFish(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommonFish
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommonFish
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommonFish(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommonFish
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommonFish
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommonFish
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommonFish
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommonFish
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommonFish        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommonFish          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommonFish = fmt.Errorf("proto: unexpected end of group")
)
